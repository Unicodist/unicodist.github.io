<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flappy Bird — Single File</title>
  <style>
    /* Basic reset */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body {
      display: flex; align-items: center; justify-content: center;
      background: linear-gradient(#74b9ff,#a29bfe);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      padding: 20px;
    }

    /* Game container */
    .game-wrap {
      width: min(480px, 95vw);
      aspect-ratio: 3 / 4; /* portrait-ish */
      background: #70c5ce;
      border-radius: 12px;
      box-shadow: 0 12px 30px rgba(10,10,20,0.25);
      position: relative; overflow: hidden;
      display: grid; place-items: center;
    }

    canvas { width:100%; height:100%; display:block; }

    /* UI overlay */
    .overlay {
      position: absolute; left: 0; right: 0; top: 0; bottom: 0;
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      pointer-events: none;
    }
    .panel {
      background: rgba(255,255,255,0.95);
      color:#111; padding: 14px 18px; border-radius: 10px; text-align:center;
      pointer-events: auto; user-select: none;
      box-shadow: 0 6px 18px rgba(10,10,20,0.12);
    }

    .controls { display:flex; gap:10px; margin-top:10px; }
    button { cursor:pointer; border:0; padding:8px 12px; border-radius:8px; background:#2d3436; color:white; }

    .scoreboard { position:absolute; left:12px; top:12px; color:white; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,0.4); }
    .scoreboard small { display:block; font-weight:400; opacity:0.9; font-size:12px; }

    /* small helpers */
    .hint { font-size:13px; opacity:0.9; }

    @media (max-width:420px){
      .panel{ font-size:14px; padding:10px 12px; }
    }
  </style>
</head>
<body>
  <div class="game-wrap" id="gameWrap">
    <canvas id="gameCanvas" width="360" height="480" aria-label="Flappy Bird style game"></canvas>

    <div class="overlay" id="overlay">
      <div class="panel" id="startPanel">
        <h2 style="margin-bottom:8px">Flappy Clone</h2>
        <div class="hint">Tap / Click / Space to flap. Survive between pipes and score points.</div>
        <div class="controls" style="margin-top:12px">
          <button id="startBtn">Start</button>
          <button id="muteBtn">Mute</button>
        </div>
        <small style="display:block;margin-top:10px; color:#555">Mobile-friendly — tap anywhere to flap.</small>
      </div>

      <div class="panel" id="gameOverPanel" style="display:none">
        <h3 id="gameOverTitle">Game Over</h3>
        <div style="margin:8px 0">Score: <strong id="finalScore">0</strong></div>
        <div style="margin-bottom:10px">Highscore: <strong id="bestScore">0</strong></div>
        <div class="controls">
          <button id="retryBtn">Try Again</button>
          <button id="shareBtn">Copy Score</button>
        </div>
      </div>
    </div>

    <div class="scoreboard" id="hud">
      <div id="score">0</div>
      <small>High: <span id="high">0</span></small>
    </div>
  </div>

  <script>
  // Flappy-like single-file implementation. Clean and commented for easy tweaks.
  (function(){
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const retryBtn = document.getElementById('retryBtn');
    const shareBtn = document.getElementById('shareBtn');
    const muteBtn = document.getElementById('muteBtn');
    const startPanel = document.getElementById('startPanel');
    const gameOverPanel = document.getElementById('gameOverPanel');
    const overlay = document.getElementById('overlay');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');
    const finalScore = document.getElementById('finalScore');
    const bestScore = document.getElementById('bestScore');

    // logical size (we draw to this size then scale by CSS) — keep consistent for physics
    const W = canvas.width = 360;
    const H = canvas.height = 480;

    // Game state
    let state = 'idle'; // 'idle' | 'playing' | 'over'
    let pipes = [];
    let frames = 0;
    let score = 0;
    let best = Number(localStorage.getItem('flappy_best') || 0);
    highEl.textContent = best;

    // Bird
    const bird = {
      x: 80,
      y: H/2,
      w: 34,
      h: 24,
      vy: 0,
      rotation: 0,
      gravity: 0.45,
      jump: -8.6,
      maxFall: 12
    };

    // Pipe settings
    const pipeGap = 125;
    const pipeWidth = 52;
    const pipeSpeed = 2.2;
    const pipeSpawnEvery = 90; // frames

    // ground (invisible collider at bottom)
    const groundY = H - 30;

    // sounds (tiny WebAudio beeps)
    let audioCtx, masterGain;
    let muted = false;
    function ensureAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain(); masterGain.gain.value = 0.18; masterGain.connect(audioCtx.destination);
    }
    function beep(freq=440, duration=0.08){
      if(muted) return;
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine'; o.frequency.value = freq;
      o.connect(g); g.connect(masterGain);
      g.gain.setValueAtTime(0.0001, audioCtx.currentTime);
      g.gain.exponentialRampToValueAtTime(1, audioCtx.currentTime + 0.01);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
      o.stop(audioCtx.currentTime + duration + 0.02);
    }

    // Input handling
    function flap(){
      if(state === 'idle') startGame();
      if(state !== 'playing') return;
      bird.vy = bird.jump;
      bird.rotation = -0.6; // tilt up
      beep(880,0.05);
    }
    window.addEventListener('keydown', e => { if(e.code === 'Space') { e.preventDefault(); flap(); } });
    window.addEventListener('mousedown', e => { flap(); });
    window.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, {passive:false});

    // UI buttons
    startBtn.addEventListener('click', startGame);
    retryBtn.addEventListener('click', resetGame);
    shareBtn.addEventListener('click', () => {
      const text = `I scored ${score} in this Flappy clone!`;
      navigator.clipboard?.writeText(text).then(()=>{
        alert('Score copied to clipboard');
      }).catch(()=> alert(text));
    });
    muteBtn.addEventListener('click', () => { muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Mute'; });

    function startGame(){
      state='playing';
      startPanel.style.display = 'none';
      gameOverPanel.style.display = 'none';
      pipes = [];
      score = 0; frames = 0;
      bird.y = H/2; bird.vy = 0; bird.rotation = 0;
      beep(660,0.06);
      // resume audio context on some browsers that block autoplay
      if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }

    function resetGame(){
      startPanel.style.display = 'none';
      gameOverPanel.style.display = 'none';
      startGame();
    }

    function endGame(){
      state = 'over';
      finalScore.textContent = score;
      best = Math.max(best, score);
      localStorage.setItem('flappy_best', best);
      bestScore.textContent = best;
      highEl.textContent = best;
      gameOverPanel.style.display = 'block';
      beep(200,0.18);
    }

    // physics & pipes
    function spawnPipe(){
      const minY = 60;
      const maxY = groundY - pipeGap - 40;
      const topY = minY + Math.random() * (Math.max(minY, maxY) - minY);
      pipes.push({ x: W + 10, top: topY, passed: false });
    }

    function update(){
      frames++;
      if(state === 'playing'){
        // spawn pipes
        if(frames % pipeSpawnEvery === 0) spawnPipe();

        // update pipes
        for(let p of pipes){ p.x -= pipeSpeed; }
        // remove off-screen
        if(pipes.length && pipes[0].x < -pipeWidth - 40) pipes.shift();

        // bird physics
        bird.vy += bird.gravity;
        if(bird.vy > bird.maxFall) bird.vy = bird.maxFall;
        bird.y += bird.vy;
        // rotation slowly toward falling angle
        bird.rotation += 0.03; if(bird.rotation > 1.1) bird.rotation = 1.1;

        // scoring: when bird passes pipe
        for(let p of pipes){
          if(!p.passed && p.x + pipeWidth < bird.x){ p.passed = true; score++; scoreElUpdate(); beep(880 - Math.min(600, score*8), 0.04); }
        }

        // collisions: ground or pipes
        if(bird.y + bird.h/2 >= groundY){ bird.y = groundY - bird.h/2; endGame(); }
        for(let p of pipes){
          // top pipe rect
          const topRect = { x: p.x, y: 0, w: pipeWidth, h: p.top };
          const botRect = { x: p.x, y: p.top + pipeGap, w: pipeWidth, h: groundY - (p.top + pipeGap) };
          if(rectCircleCollide(topRect, bird) || rectCircleCollide(botRect, bird)){
            endGame(); break;
          }
        }
      } else {
        // idle floating animation
        bird.rotation = Math.sin(frames/20) * 0.2;
      }
    }

    function scoreElUpdate(){ scoreEl.textContent = score; }

    // collision between axis-aligned rect and circle approximating the bird
    function rectCircleCollide(rect, bird){
      const cx = bird.x, cy = bird.y, r = Math.max(bird.w,bird.h)/2 - 2;
      const rx = rect.x, ry = rect.y, rw = rect.w, rh = rect.h;
      // closest point
      const closestX = Math.max(rx, Math.min(cx, rx+rw));
      const closestY = Math.max(ry, Math.min(cy, ry+rh));
      const dx = cx - closestX, dy = cy - closestY;
      return (dx*dx + dy*dy) < (r*r);
    }

    // drawing
    function draw(){
      // clear & background
      ctx.clearRect(0,0,W,H);

      // sky gradient
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#70c5ce'); g.addColorStop(1,'#5ec0da');
      ctx.fillStyle = g; ctx.fillRect(0,0,W,H);

      // pipes
      for(let p of pipes){
        drawPipe(p.x, 0, pipeWidth, p.top, true);
        drawPipe(p.x, p.top + pipeGap, pipeWidth, groundY - (p.top + pipeGap), false);
      }

      // ground (simple band)
      ctx.fillStyle = '#d8a058'; ctx.fillRect(0, groundY, W, H-groundY);
      ctx.fillStyle = '#c89245'; ctx.fillRect(0, groundY+4, W, 8);

      // bird (circle-ish + eye) with rotation
      ctx.save();
      ctx.translate(bird.x, bird.y);
      ctx.rotate(bird.rotation);

      // body
      ctx.beginPath(); ctx.ellipse(0,0, bird.w/2, bird.h/2, 0, 0, Math.PI*2); ctx.fillStyle = '#ffd23f'; ctx.fill();
      // wing
      ctx.beginPath(); ctx.ellipse(-3, 2, 10, 5, -0.8, 0, Math.PI*2); ctx.fillStyle = '#ffb62f'; ctx.fill();
      // eye
      ctx.beginPath(); ctx.arc(8,-2,3,0,Math.PI*2); ctx.fillStyle = '#222'; ctx.fill();
      ctx.restore();

      // HUD: score big
      if(state === 'idle'){
        ctx.save(); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.font='18px system-ui, Arial'; ctx.textAlign='center';
        ctx.fillText('Click / Tap / Space to flap', W/2, H*0.2);
        ctx.restore();
      }

    }

    

    function drawPipe(x,y,w,h, flipped){
      ctx.save();
      ctx.translate(x,y);
      // pipe body
      ctx.fillStyle = '#3bb54a'; ctx.fillRect(0,0,w,h);
      // pipe rim
      ctx.fillStyle = '#2a8c38'; ctx.fillRect(-4, flipped ? h-12 : -8, w+8, 8);
      ctx.restore();
    }

    function loop(){ update(); draw();
      if(state === 'over'){
        // show overlay panel
        // (only show once) - panel display handled in endGame
      }
      requestAnimationFrame(loop);
    }

    // boot
    draw(); // initial frame
    loop();

  })();
  </script>
</body>
</html>
